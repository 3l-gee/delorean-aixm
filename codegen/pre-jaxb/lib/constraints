import xml.etree.ElementTree as ET
from .annotation import Tag

    
class Constraints: 
    @staticmethod
    def generate_constraints(element) :

        res = {"type" : element.attrib["name"]}
        union = element.find(Tag.union)

        if union is not None:
            enum = []
            simple_types = union.findall(Tag.simple_type)
            for simple_type in simple_types:
                restriction = simple_type.find(Tag.restriction)
                pattern = restriction.find(Tag.pattern)
                enumerations = restriction.findall(Tag.enumeration)
                for enumeration in enumerations:
                    enum.append(enumeration.attrib["value"])
                
                if pattern is not None:
                    enum.append(pattern.attrib["value"])
            res["enum"] = enum
            return res

        restriction = element.find(Tag.restriction)
        if restriction is None:
            return res
    
        base = restriction.attrib["base"]
        fractionDigits = restriction.find(Tag.fractionDigits)
        length = restriction.find(Tag.length)
        maxExclusive = restriction.find(Tag.maxExclusive)
        minExclusive = restriction.find(Tag.minExclusive)
        maxInclusive = restriction.find(Tag.maxInclusive)
        minInclusive = restriction.find(Tag.minInclusive)
        maxLength = restriction.find(Tag.maxLength)
        minLength = restriction.find(Tag.minLength)
        pattern = restriction.find(Tag.pattern)
        totalDigits = restriction.find(Tag.totalDigits)
        whiteSpace = restriction.find(Tag.whiteSpace)

        if base is not None:
            if base == "string":
                res["column_definition"] = "TEXT"
            elif base == "integer":
                res["column_definition"] = "INTEGER"
            elif base == "decimal":
                res["column_definition"] = "DECIMAL" 
            elif base == "boolean":
                res["column_definition"] = "BOOLEAN"
            elif base == "date":
                res["column_definition"] = "DATE"
            elif base == "dateTime":
                res["column_definition"] = "TIMESTAMP"
            elif base == "time":
                res["column_definition"] = "TIME"

        # if fractionDigits is not None:
        #     pass

        # if length is not None:
        #     pass

        # if maxExclusive is not None:
        #     pass

        # if minExclusive is not None:
        #     pass
    
        # if maxInclusive is not None:
        #     pass

        # if minInclusive is not None:
            pass

        if length is not None:
            res["column_length"] = length.attrib["value"]

        # if maxLength is not None:
        #     res["column_length"] = maxLength.attrib["value"]

        # if minLength is not None or maxLength is not None:
        #     res["size"] = (Annox.field_add(Jpa.constraint.size(minLength.attrib["value"], maxLength.attrib["value"])))

        # if pattern is not None:
        #     res["pattern"] = (Annox.field_add(Jpa.constraint.pattern(pattern.attrib["value"], "this field must match")))

        # if totalDigits is not None:
        #     pass

        # if whiteSpace is not None:
        #     pass        
            
        return res
